1.1. Зачем изучать алгоритмы?
Позвольте мне сначала обосновать актуальность этой книги, указав несколько
причин, почему так важно быть мотивированным в изучении алгоритмов. Так
что же такое алгоритм, в конце концов? Это набор четко сформулированных
правил, в сущности, рецепт для решения некоторой вычислительной задачи.
Может быть, у вас имеется куча чисел и вы хотите перераспределить их так,
чтобы расположить их в отсортированном порядке. Возможно, у вас есть
дорожная карта и необходимо вычислить кратчайший путь от некоторой
исходной точки до определенного места назначения. Вполне вероятно, вам
требуется выполнить несколько задач до наступления установленных сроков,
в таком случае вы заинтересованы в упорядочении выполнения этих задач,
для того чтобы вовремя все их завершить.
Итак, зачем же изучать алгоритмы?
Важность для всех отраслей computer science. Во-первых, понимание основ
алгоритмизации и тесно с ней взаимосвязанной сферы организации структур
данных необходимо для выполнения серьезной работы практически в любой
отрасли информатики. Например, в Стэнфордском университете для полу-
1.1. Зачем изучать алгоритмы? 23
чения любой степени по Computer Science (будь то бакалавр, магистр наук
и даже доктор наук) обязательно требуется пройти курс алгоритмов. Приведу
всего несколько примеров:
1.	 Протоколы маршрутизации в коммуникационных сетях задействуют
классические алгоритмы поиска кратчайшего пути.
2.	 Криптография с открытым ключом опирается на эффективные теоретико-числовые алгоритмы.
3.	 Компьютерная графика требует вычислительных примитивов, предоставляемых геометрическими алгоритмами.
4.	 Индексация в базах данных опирается на структуры данных сбалансированных деревьев поиска.
5.	 Вычислительная биология использует алгоритмы динамического программирования для измерения сходства геномов.
Приведенный список можно продолжать.
Двигатель технологических инноваций. Во-вторых, алгоритмы играют
ключевую роль в современных технологических инновациях. Приведу только один очевидный пример: поисковые системы используют целую мозаику
алгоритмов для эффективного вычисления релевантности различных вебстраниц заданному поисковому запросу. Наиболее известным подобным
алгоритмом является алгоритм PageRank, используемый в настоящее время
Google. В самом деле, в докладе за декабрь 2010 года для Белого дома
США президентский консультативный совет на науке и технике написал
следующее:
«Все знают Закон Мура — предсказание, сделанное в 1965 г. соучредителем Intel Гордоном Муром о том, что плотность транзисторов
в интегральных схемах будет удваиваться каждые 1–2 года... Во многих
областях прирост производительности за счет улучшения алгоритмов
значительно превысил даже впечатляющий рост производительности
за счет увеличения скорости процессоров»1
.
1 Выдержка из доклада президенту и конгрессу: Проектирование цифрового будущего, декабрь 2010 г. (с. 71).
24   Глава 1. Введение
Новый взгляд на достижения других наук. В-третьих (хотя это выходит
за рамки этой книги), алгоритмы все более и более используются в качестве
«увеличительного стекла», чтобы по-новому взглянуть на научные проблемы
за пределами computer science и IT. Например, исследование квантовых вычислений обеспечило новый вычислительный взгляд на квантовую механику.
Ценовые колебания на экономических рынках могут плодотворно рассматриваться как алгоритмический процесс. Даже эволюцию можно рассматривать
как удивительно эффективный алгоритм поиска.
Гимнастика для мозга. Во времена студенчества моими любимыми всегда
были сложные предметы. После их освоения всегда оставалось ощущение,
что я становился на несколько пунктов IQ умнее, чем в начале изучения. Надеюсь, моя книга позволит вам получить аналогичный опыт.
Удовольствие! Я надеюсь, что к концу этой книги вы поймете, почему разработка и анализ алгоритмов просто приносит удовольствие! Это увлекательное
занятие, которое требует редкого сочетания точности и креативности. Разумеется, временами эта работа может разочаровывать, но она также очень
затягивает. И давайте не будем забывать о том, что обучение алгоритмам, по
сути, сопровождает вас с самого детства.
1.2. Целочисленное умножение
1.2.1. Задачи и решения
Когда вы учились в начальной школе, вы, скорее всего, изучали умножение
двух чисел в столбик, что, по сути, является алгоритмом — четко сформулированным набором правил для преобразования входа (два числа) в выход (их
произведение). Всегда важно понимать разницу между постановкой (описанием) решаемой задачи и описанием метода ее решения (то есть алгоритма
этой задачи). В этой книге мы будем систематически придерживаться схемы,
в которой сначала производится постановка вычислительной задачи (данные
на входе и требуемый результат на выходе), а затем дается описание одного
или нескольких алгоритмов ее решения.
1.2. Целочисленное умножение 25
1.2.2. Задача целочисленного умножения
В задаче целочисленного умножения входными данными являются два
n-разрядных числа, обозначим их x и y. Разрядность (длина) n чисел x и y
может быть любым положительным целым числом. Однако я призываю вас
оперировать большими значениями n, в тысячах или более1
. (Представьте,
что вы разрабатываете некое криптографическое приложение, ведь они манипулируют очень большими числами.) В задаче целочисленного умножения
требуемым выходом является результат произведения x ? y.
ЗАДАЧА. ЦЕЛОЧИСЛЕННОЕ УМНОЖЕНИЕ
Вход: два n-значных неотрицательных целых числа, x и y.
Выход: произведение x ? y.
1.2.3. Алгоритм начальной школы
Точно определив вычислительную задачу, мы опишем алгоритм, который
ее решает, — тот самый алгоритм, который вы изучали в начальной школе.
Мы оценим производительность этого алгоритма числом «примитивных
операций», которые он выполняет, в виде функции от количества знаков n
в каждом входном числе. Пока же давайте представим примитивную операцию как любую из следующих: (i) сложение двух одноразрядных (n = 1)
чисел; (ii) умножение двух одноразрядных чисел или (iii) добавление нуля
к началу или концу числа.
Чтобы освежить вашу память, рассмотрим конкретный пример умножения
x = 5678 на y = 1234 (здесь n = 4) в столбик, см. рис. 1.1. Сначала алгоритм вы1 Если вы хотите перемножить числа с разными длинами (например, 1234 и 56), просто добавьте несколько нулей в начало меньшего числа (например, рассматривайте
56 как 0056). С другой стороны, алгоритмы, которые мы обсудим, могут быть приспособлены для чисел с разной длиной.
26   Глава 1. Введение
числяет «частичное произведение» первого числа и последней цифры второго
числа: 5678 ? 4 = 22 712. Вычисление этого частичного произведения сводится
к умножению каждой цифры первого числа на 4, записи младшего разряда
результата, запоминанию («переносу» на следующий этап) старшего разряда
и добавлению этих «переносов» (если они есть) на следующем умножении1
.
При вычислении следующего частичного произведения (5678 ? 3 = 17 034)
мы делаем то же самое, сдвигая результат на один знак влево (фактически
добавляя «0» в конце). И так далее для оставшихся двух частичных произведений. Заключительный шаг состоит в том, чтобы сложить все частичные
произведения.
Тогда в третьем классе вы, вероятно, согласились, что этот алгоритм является
правильным, имея в виду, что неважно, с каких чисел x и y начинать. При
условии, что все промежуточные вычисления выполняются правильно, алгоритм в конечном итоге заканчивается получением результата произведения
x ? y двух исходных чисел.
5678
? 1234
22712
17034
11356
5678
7006652
? 2n операций
(на строку)
n строк
Рис. 1.1. Алгоритм целочисленного умножения в столбик
Таким образом, вы никогда не получите неправильный ответ, и алгоритм не
может зациклиться.
1 8 ? 4 = 32, 2 пишем, 3 «переносим», 7 ? 4 = 28, плюс 3 равняется 31, 1 пишем,
3 переносим, и так далее...
1.2. Целочисленное умножение 27
1.2.4. Анализ числа операций
Ваш школьный учитель, возможно, не обсуждал число примитивных операций, необходимых для завершения процедуры умножения в столбик. В нашем примере, для того чтобы вычислить первое частичное произведение,
мы умножили 4 раза каждую из цифр 5, 6, 7, 8 первого числа. Это четыре
примитивные операции. Мы также выполнили несколько сложений из-за переносов. В общем случае вычисление частичного произведения влечет за собой
n умножений (одно умножение на один знак) и не более n сложений (не более
одного на один знак). Всего получается не более 2n примитивных операций.
Первое частичное произведение ничем не отличается от других, и каждое из
них требует не более 2n операций. Поскольку имеется n частичных произведений — по одному на каждый знак второго числа, — вычисление всех из
них требует не более n ? 2n = 2n2
 примитивных операций. Чтобы вычислить
окончательный ответ, нам все еще нужно все частичные произведения сложить
вместе, но для этого требуется сопоставимое число операций (не более чем
еще 2n2
). Подведем итоги:
2
=4
общее количество операций ? ? констант
14243а n .
Рассуждая о том, каким образом объем работы, который этот алгоритм выполняет, возрастает по мере того, как исходные множители становятся все
длиннее и длиннее, мы видим, что объем выполняемых операций растет
квадратически, следуя за увеличением разрядности. Если удвоить длину исходных множителей, то требуемый объем операций подскакивает в 4 раза.
Увеличьте их длину в 4 раза, и она подскочит в 16 раз, и так далее.
1.2.5. Можно ли добиться лучшего?
В зависимости от того, каким третьеклассником вы были, вы вполне могли
принять эту процедуру как уникальный или, по крайней мере, оптимальный способ умножения двух чисел. Если вы захотите стать серьезным
проектировщиком алгоритмов, то нужно будет преодолеть эту робость.
Классическая книга по алгоритмам Ахо, Хопкрофта и Ульмана, после
итеративного рассмотрения целого ряда методик разработки алгоритмов,
говорит следующее:
28   Глава 1. Введение
«Для хорошего разработчика алгоритмов, пожалуй, самый важный принцип состоит в том, чтобы отказаться от соглашательства»1
.
Или как я люблю говорить, что каждый разработчик алгоритмов должен
принять как должное:
Можно ли добиться лучшего?
Этот вопрос особенно актуален, когда вы сталкиваетесь с очевидным или
прямым решением вычислительной задачи. В третьем классе вы, возможно,
не задавались вопросом о том, можно ли выстроить путь решения лучше, чем
это делает простой классический алгоритм умножения в столбик. Настало
время задать этот вопрос и дать на него ответ.